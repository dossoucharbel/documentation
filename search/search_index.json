{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the R-Type game development project documentation. This documentation is designed to guide you through all the steps required to understand, design and contribute to this exciting video game development project.","title":"Home"},{"location":"#welcome","text":"to the R-Type game development project documentation. This documentation is designed to guide you through all the steps required to understand, design and contribute to this exciting video game development project.","title":"Welcome"},{"location":"about/","text":"R-Type Game Development Project Documentation Welcome to the R-Type Game Development Project documentation. This documentation aims to guide you through all the steps necessary to understand, design and contribute to this exciting video game development project.","title":"R-Type Game Development Project Documentation"},{"location":"about/#r-type-game-development-project-documentation","text":"","title":"R-Type Game Development Project Documentation"},{"location":"about/#welcome-to-the-r-type-game-development-project-documentation-this-documentation-aims-to-guide-you-through-all-the-steps-necessary-to-understand-design-and-contribute-to-this-exciting-video-game-development-project","text":"","title":"Welcome to the R-Type Game Development Project documentation. This documentation aims to guide you through all the steps necessary to understand, design and contribute to this exciting video game development project."},{"location":"button/","text":"Button Class reference class for handle button include \"Button.hpp\" Public Member Functions Button() Default constructor for construct a new button. Button(std::string t, sf::Vector2f size, sf::Color bgColor, sf::Color textColor, sf::Font &font) Construct a new Button object. Parameters t size bgColor textColor font ~Button() Destroy the button object. void setBackColor(sf::Color color) Set the Back Color object. void setTextColor(sf::Color color) Set the Text Color object. void setFont(sf::Font &font) Set the Font object. void setPosition(sf::Vector2f pos) Set the Position object. void draw_button (std::shared_ptr< sf::RenderWindow >(window)) Draw a button. void set_size (sf::Vector2f size) Set the size object. void set_name (std::string name) Set the name object. bool isMouseOver (std::shared_ptr< sf::RenderWindow > window)< check is mouse over the button","title":"Button Class reference"},{"location":"button/#button-class-reference","text":"class for handle button include \"Button.hpp\"","title":"Button Class reference"},{"location":"button/#public-member-functions","text":"","title":"Public Member Functions"},{"location":"button/#button","text":"Default constructor for construct a new button. Button(std::string t, sf::Vector2f size, sf::Color bgColor, sf::Color textColor, sf::Font &font) Construct a new Button object.","title":"Button()"},{"location":"button/#parameters","text":"t size bgColor textColor font","title":"Parameters"},{"location":"button/#button_1","text":"Destroy the button object.","title":"~Button()"},{"location":"button/#void-setbackcolorsfcolor-color","text":"Set the Back Color object.","title":"void setBackColor(sf::Color color)"},{"location":"button/#void-settextcolorsfcolor-color","text":"Set the Text Color object.","title":"void setTextColor(sf::Color color)"},{"location":"button/#void-setfontsffont-font","text":"Set the Font object.","title":"void setFont(sf::Font &amp;font)"},{"location":"button/#void-setpositionsfvector2f-pos","text":"Set the Position object.","title":"void setPosition(sf::Vector2f pos)"},{"location":"button/#void-draw_button-stdshared_ptr-sfrenderwindow-window","text":"Draw a button.","title":"void draw_button (std::shared_ptr&lt; sf::RenderWindow &gt;(window))"},{"location":"button/#void-set_size-sfvector2f-size","text":"Set the size object.","title":"void set_size (sf::Vector2f size)"},{"location":"button/#void-set_name-stdstring-name","text":"Set the name object.","title":"void set_name (std::string name)"},{"location":"button/#bool-ismouseover-stdshared_ptr-sfrenderwindow-window","text":"check is mouse over the button","title":"bool isMouseOver (std::shared_ptr&lt; sf::RenderWindow &gt; window)&lt;"},{"location":"client/","text":"Client Class reference Class for handle button include \"Client.hpp\" The Client class uses Boost.Asio to manage network communication, in particular with the UDP protocol. Public Member Functions Client(boost::asio::io_context& io_context, const std::string& host, const std::string& port); Construct a new client object.It takes a reference to an io_context object, as well as strings to specify the host and port to connect to. It initializes the client's configuration for network communication. Paramaters io_context host port Client() Construct a new client object. ~Client() Destroy the client object void init(const std::string &host, const std::string &port) init setting for the client. It is used to initialize the parameters of the Client object with the host and port values. Parameters host port","title":"Client Class reference"},{"location":"client/#client-class-reference","text":"Class for handle button include \"Client.hpp\" The Client class uses Boost.Asio to manage network communication, in particular with the UDP protocol.","title":"Client Class reference"},{"location":"client/#public-member-functions","text":"","title":"Public Member Functions"},{"location":"client/#clientboostasioio_context-io_context-const-stdstring-host-const-stdstring-port","text":"Construct a new client object.It takes a reference to an io_context object, as well as strings to specify the host and port to connect to. It initializes the client's configuration for network communication.","title":"Client(boost::asio::io_context&amp; io_context, const std::string&amp; host, const std::string&amp; port);"},{"location":"client/#paramaters","text":"io_context host port","title":"Paramaters"},{"location":"client/#client","text":"Construct a new client object.","title":"Client()"},{"location":"client/#client_1","text":"Destroy the client object","title":"~Client()"},{"location":"client/#void-initconst-stdstring-host-const-stdstring-port","text":"init setting for the client. It is used to initialize the parameters of the Client object with the host and port values.","title":"void init(const std::string &amp;host, const std::string &amp;port)"},{"location":"client/#parameters","text":"host port","title":"Parameters"},{"location":"dev/","text":"Welcome to the R-type \"Developer's Guide\". This guide has been designed to help you understand, configure and contribute to our R-type game project. Whether you're an experienced developer looking to dive straight into source code, or a novice with a passion for game development, this guide will provide you with the essential information you need to get started. Purpose of the Guide : This guide aims to provide you with : Clear instructions for configuring the development environment. Simple steps for cloning the project from our repository. Information on managing dependencies and libraries. Tips for compiling the game and running the server (if necessary). Full documentation of essential APIs and core game elements. Commented code examples to illustrate concepts.","title":"Developer's Guide"},{"location":"dev/#welcome-to-the-r-type-developers-guide-this-guide-has-been-designed-to-help-you-understand-configure-and-contribute-to-our-r-type-game-project-whether-youre-an-experienced-developer-looking-to-dive-straight-into-source-code-or-a-novice-with-a-passion-for-game-development-this-guide-will-provide-you-with-the-essential-information-you-need-to-get-started","text":"","title":"Welcome to the R-type \"Developer's Guide\". This guide has been designed to help you understand, configure and contribute to our R-type game project. Whether you're an experienced developer looking to dive straight into source code, or a novice with a passion for game development, this guide will provide you with the essential information you need to get started."},{"location":"dev/#purpose-of-the-guide","text":"This guide aims to provide you with : Clear instructions for configuring the development environment. Simple steps for cloning the project from our repository. Information on managing dependencies and libraries. Tips for compiling the game and running the server (if necessary). Full documentation of essential APIs and core game elements. Commented code examples to illustrate concepts.","title":"Purpose of the Guide :"},{"location":"entity/","text":"Client Entity_t reference include \"IEntity.hpp\" The entity_t class is designed to represent an entity in an unspecified context. It is used to store an id associated with the entity. Public Member Functions Entity(std::size_t id) Construct a new entity_t. Entity_t() A default constructor that creates an entity_t object without specifying an identifier. ~Entity_t() Destroy the entity_t object. operator std::size_t() const This operator allows an entity_t object to be used in an expression as if it were a std::size_t. It simply returns the entity id. Example /-------------------------------------------------------------------------------------------------- |entity_t entity1(42); // Creates an entity with identifier 42\\ | std::size_t id = entity1; // Use the conversion operator to obtain the identifier\\ | entity_t entity2; // Creates an entity without specifying an identifier\\ | std::size_t id2 = entity2; // The identifier will be uninitialized (undefined behavior) \\ |---------------------------------------------------------------------------------------------------","title":"Client Entity_t reference"},{"location":"entity/#client-entity_t-reference","text":"include \"IEntity.hpp\" The entity_t class is designed to represent an entity in an unspecified context. It is used to store an id associated with the entity.","title":"Client Entity_t reference"},{"location":"entity/#public-member-functions","text":"","title":"Public Member Functions"},{"location":"entity/#entitystdsize_t-id","text":"Construct a new entity_t.","title":"Entity(std::size_t id)"},{"location":"entity/#entity_t","text":"A default constructor that creates an entity_t object without specifying an identifier.","title":"Entity_t()"},{"location":"entity/#entity_t_1","text":"Destroy the entity_t object.","title":"~Entity_t()"},{"location":"entity/#operator-stdsize_t-const","text":"This operator allows an entity_t object to be used in an expression as if it were a std::size_t. It simply returns the entity id.","title":"operator std::size_t() const"},{"location":"entity/#example","text":"/-------------------------------------------------------------------------------------------------- |entity_t entity1(42); // Creates an entity with identifier 42\\ | std::size_t id = entity1; // Use the conversion operator to obtain the identifier\\ | entity_t entity2; // Creates an entity without specifying an identifier\\ | std::size_t id2 = entity2; // The identifier will be uninitialized (undefined behavior) \\ |---------------------------------------------------------------------------------------------------","title":"Example"},{"location":"game/","text":"Game architecture R-Type's game architecture is designed to deliver a compelling single-player or multiplayer experience. Here's an overview of the key classes and components that form the basis of our architecture. Class Here are the classes, structs, unions and interfaces with brief descriptions: Button Class for handle button Client Class for client service network CreateRoom Class for creation of a room for multiplayer game Entity_t ECS Game Class for game logic IClient Client interface JoinRoom Join room after login I_queue ListRoom Class for listing room for client Lobby LoginPage Class login page logic Messasges Player Player class Registry Class for handle registry Room Class for playerRoom Server Sound Class for Sound sparse_array Sprite Sprite class Text Handle text TextBox Text input class Window Handle window The diagram above illustrates the main game classes and their relationships. You can see how GameServer and GameClient interact to maintain game state and provide an immersive user experience. Data flow Game data flows between the GameServer and GameClients. Players send their actions to the server, which processes the commands, updates the game state, then sends the data back to the clients. Interactions, such as shooting, are handled by the collision system. Event management We use an event system to manage interactions between classes. For example, when a player shoots an enemy, an event is triggered to manage damage and effects. Good coding practices We follow PEP 8 naming conventions to ensure code consistency. All classes are documented with docstrings to explain their use and methods. External resources We use the XYZ network library to manage communication between server and clients. You can find the documentation for this library here","title":"Game Architecture"},{"location":"game/#game-architecture","text":"R-Type's game architecture is designed to deliver a compelling single-player or multiplayer experience. Here's an overview of the key classes and components that form the basis of our architecture.","title":"Game architecture"},{"location":"game/#class","text":"Here are the classes, structs, unions and interfaces with brief descriptions: Button Class for handle button Client Class for client service network CreateRoom Class for creation of a room for multiplayer game Entity_t ECS Game Class for game logic IClient Client interface JoinRoom Join room after login I_queue ListRoom Class for listing room for client Lobby LoginPage Class login page logic Messasges Player Player class Registry Class for handle registry Room Class for playerRoom Server Sound Class for Sound sparse_array Sprite Sprite class Text Handle text TextBox Text input class Window Handle window The diagram above illustrates the main game classes and their relationships. You can see how GameServer and GameClient interact to maintain game state and provide an immersive user experience.","title":"Class"},{"location":"game/#data-flow","text":"Game data flows between the GameServer and GameClients. Players send their actions to the server, which processes the commands, updates the game state, then sends the data back to the clients. Interactions, such as shooting, are handled by the collision system.","title":"Data flow"},{"location":"game/#event-management","text":"We use an event system to manage interactions between classes. For example, when a player shoots an enemy, an event is triggered to manage damage and effects.","title":"Event management"},{"location":"game/#good-coding-practices","text":"We follow PEP 8 naming conventions to ensure code consistency. All classes are documented with docstrings to explain their use and methods.","title":"Good coding practices"},{"location":"game/#external-resources","text":"We use the XYZ network library to manage communication between server and clients. You can find the documentation for this library here","title":"External resources"},{"location":"iclient/","text":"IClient Class Reference client interface include \"IClient.hpp\" Public Member Functions IClient() Construct a new IClient object. ~IClient () Destroy the IClient object. void startGame() This function is used to start the game. void handle_event(sf::Event event, std::shared_ptr< sf::RenderWindow >(wwindow), int *sf) The function that handles events related to the game window. Client &get_client() A function that returns a reference to the Client object, allowing access to connection management functionalities.","title":"IClient Class Reference"},{"location":"iclient/#iclient-class-reference","text":"client interface include \"IClient.hpp\"","title":"IClient Class Reference"},{"location":"iclient/#public-member-functions","text":"","title":"Public Member Functions"},{"location":"iclient/#iclient","text":"Construct a new IClient object.","title":"IClient()"},{"location":"iclient/#iclient_1","text":"Destroy the IClient object.","title":"~IClient ()"},{"location":"iclient/#void-startgame","text":"This function is used to start the game.","title":"void startGame()"},{"location":"iclient/#void-handle_eventsfevent-event-stdshared_ptr-sfrenderwindow-wwindow-int-sf","text":"The function that handles events related to the game window.","title":"void handle_event(sf::Event event, std::shared_ptr&lt; sf::RenderWindow &gt;(wwindow), int *sf)"},{"location":"iclient/#client-get_client","text":"A function that returns a reference to the Client object, allowing access to connection management functionalities.","title":"Client &amp;get_client()"},{"location":"intro/","text":"Introduction to Project R-Type Welcome to the R-Type project, an exciting adventure in the world of video game development. This documentation will guide you through all the steps required to understand, design and contribute to this ambitious project. The world of R-Type R-Type is a legendary video game that has marked generations of gamers. It belongs to the \"shoot'em up\" or \"shmup\" genre, where the player pilots a spaceship and battles relentless waves of enemies. The game is renowned for its frenetic gameplay, iconic graphics and unforgettable soundscape. If you're not already familiar with R-Type, get ready to discover a timeless classic in video game history. Project objectives The main aim of this project is to recreate the R-Type experience, but with a modern twist. This means setting up a multi-threaded server and graphics client to enable players to compete and cooperate online. We're not just creating an R-Type clone; we're aiming to demonstrate advanced game development and software engineering skills. Project context The R-Type project takes place in the context of networked video game development, a demanding field that calls on a variety of technical skills, from server architecture to the creation of a fluid and entertaining gaming experience. . In addition to creating an online version of R-Type, we're also exploring game design concepts, advanced architectural models and modern development practices. Your Adventure Begins Here Whether you're an experienced developer or a game enthusiast, this project offers a unique opportunity to learn, create and collaborate. This documentation is your guide to navigating this exciting world. You'll find detailed information on game architecture, APIs, coding best practices and much more. We invite you to immerse yourself in the R-Type project and contribute to its development. Your passion, creativity and skills will play a vital role in bringing this ambitious project to fruition. Let the adventure begin!","title":"Intro"},{"location":"intro/#introduction-to-project-r-type","text":"Welcome to the R-Type project, an exciting adventure in the world of video game development. This documentation will guide you through all the steps required to understand, design and contribute to this ambitious project.","title":"Introduction to Project R-Type"},{"location":"intro/#the-world-of-r-type","text":"R-Type is a legendary video game that has marked generations of gamers. It belongs to the \"shoot'em up\" or \"shmup\" genre, where the player pilots a spaceship and battles relentless waves of enemies. The game is renowned for its frenetic gameplay, iconic graphics and unforgettable soundscape. If you're not already familiar with R-Type, get ready to discover a timeless classic in video game history.","title":"The world of R-Type"},{"location":"intro/#project-objectives","text":"The main aim of this project is to recreate the R-Type experience, but with a modern twist. This means setting up a multi-threaded server and graphics client to enable players to compete and cooperate online. We're not just creating an R-Type clone; we're aiming to demonstrate advanced game development and software engineering skills.","title":"Project objectives"},{"location":"intro/#project-context","text":"The R-Type project takes place in the context of networked video game development, a demanding field that calls on a variety of technical skills, from server architecture to the creation of a fluid and entertaining gaming experience. . In addition to creating an online version of R-Type, we're also exploring game design concepts, advanced architectural models and modern development practices.","title":"Project context"},{"location":"intro/#your-adventure-begins-here","text":"Whether you're an experienced developer or a game enthusiast, this project offers a unique opportunity to learn, create and collaborate. This documentation is your guide to navigating this exciting world. You'll find detailed information on game architecture, APIs, coding best practices and much more. We invite you to immerse yourself in the R-Type project and contribute to its development. Your passion, creativity and skills will play a vital role in bringing this ambitious project to fruition.","title":"Your Adventure Begins Here"},{"location":"intro/#let-the-adventure-begin","text":"","title":"Let the adventure begin!"},{"location":"introduction/","text":"The R-Type project is an exciting adventure into the world of networked game development. It offers an exceptional opportunity to explore advanced development techniques while putting software engineering best practices into practice. Our ultimate goal is to implement a multi-threaded server and graphics client for an adaptation of the beloved video game, R-Type. What you'll find in this documentation This documentation is designed to provide you with all the essential information you need to participate in the R-Type project. You'll find out : Introduction to the Project : A detailed presentation of the R-Type project, its objectives and background. Game Architecture : An overview of the game's key components, architectural diagrams and interactions. Developer's Guide : Step-by-step instructions for configuring our development environment, building the game and understanding the essential APIs. Coding Best Practices : Coding standards and recommendations to ensure code consistency and development quality. Network Protocol Documentation : A detailed description of the commands and packets exchanged between server and client. FAQ : A list of questions","title":"Introduction"},{"location":"introduction/#the-r-type-project-is-an-exciting-adventure-into-the-world-of-networked-game-development-it-offers-an-exceptional-opportunity-to-explore-advanced-development-techniques-while-putting-software-engineering-best-practices-into-practice-our-ultimate-goal-is-to-implement-a-multi-threaded-server-and-graphics-client-for-an-adaptation-of-the-beloved-video-game-r-type","text":"","title":"The R-Type project is an exciting adventure into the world of networked game development. It offers an exceptional opportunity to explore advanced development techniques while putting software engineering best practices into practice. Our ultimate goal is to implement a multi-threaded server and graphics client for an adaptation of the beloved video game, R-Type."},{"location":"introduction/#what-youll-find-in-this-documentation","text":"This documentation is designed to provide you with all the essential information you need to participate in the R-Type project. You'll find out : Introduction to the Project : A detailed presentation of the R-Type project, its objectives and background. Game Architecture : An overview of the game's key components, architectural diagrams and interactions. Developer's Guide : Step-by-step instructions for configuring our development environment, building the game and understanding the essential APIs. Coding Best Practices : Coding standards and recommendations to ensure code consistency and development quality. Network Protocol Documentation : A detailed description of the commands and packets exchanged between server and client. FAQ : A list of questions","title":"What you'll find in this documentation"},{"location":"ique/","text":"l_queue< T > Class This Class represents a queue Public Member Functions void push(T value) This method adds an element of type T to the end of the queue. It is protected by a lock to ensure security when adding elements. T pop() This method retrieves and deletes the element at the head of the queue, then returns it. It is also protected by a lock to ensure secure data access. bool empty() This method returns true if the queue is empty, otherwise false. It is also protected by a lock to ensure data consistency.","title":"l_queue< T > Class"},{"location":"ique/#l_queue-t-class","text":"This Class represents a queue","title":"l_queue&lt; T &gt; Class"},{"location":"ique/#public-member-functions","text":"","title":"Public Member Functions"},{"location":"ique/#void-pusht-value","text":"This method adds an element of type T to the end of the queue. It is protected by a lock to ensure security when adding elements.","title":"void push(T value)"},{"location":"ique/#t-pop","text":"This method retrieves and deletes the element at the head of the queue, then returns it. It is also protected by a lock to ensure secure data access.","title":"T pop()"},{"location":"ique/#bool-empty","text":"This method returns true if the queue is empty, otherwise false. It is also protected by a lock to ensure data consistency.","title":"bool empty()"},{"location":"join/","text":"JoinRoom Class Reference join room after login. include \"join_room.hpp\" Public Member Functions JoinRoom() Construct a new Join Room object. ~JoinRoom () Destroy the Join Room object. Void handle_event (sf::Event event, std::shared_ptr< sf::RenderWindow > window, Client &client) This fonction manages events linked to the game window, such as closing the window, detecting when the \"Start\" button is hovered over and clicking on it. It also sends a message to the server to indicate that the user wishes to join the room. std::string get_room_name() Get the room name object int get_run () Returns the execution status of the JoinRoom class. void set_room_name (std::string name) Set the room name object. void set_run (int state) Defines the execution state of the JoinRoom class. void draw_lpage (std::shared_ptr< sf::RenderWindow > *window) A public method that draws the \"Start\" button and the game room on the specified window. voidcstart_lobby (Window &window, registry &r, ISystem sys, int *run, Client &client) The public method that manages the game waiting room process. It sends a message to the server to indicate that the user wishes to join the room, then handles window events, renders the game system and the waiting room.","title":"JoinRoom Class Reference"},{"location":"join/#joinroom-class-reference","text":"join room after login. include \"join_room.hpp\"","title":"JoinRoom Class Reference"},{"location":"join/#public-member-functions","text":"","title":"Public Member Functions"},{"location":"join/#joinroom","text":"Construct a new Join Room object.","title":"JoinRoom()"},{"location":"join/#joinroom_1","text":"Destroy the Join Room object.","title":"~JoinRoom ()"},{"location":"join/#void-handle_event-sfevent-event-stdshared_ptr-sfrenderwindow-window-client-client","text":"This fonction manages events linked to the game window, such as closing the window, detecting when the \"Start\" button is hovered over and clicking on it. It also sends a message to the server to indicate that the user wishes to join the room.","title":"Void handle_event (sf::Event event, std::shared_ptr&lt; sf::RenderWindow &gt; window, Client &amp;client)"},{"location":"join/#stdstring-get_room_name","text":"Get the room name object","title":"std::string  get_room_name()"},{"location":"join/#int-get_run","text":"Returns the execution status of the JoinRoom class.","title":"int get_run ()"},{"location":"join/#void-set_room_name-stdstring-name","text":"Set the room name object.","title":"void set_room_name (std::string name)"},{"location":"join/#void-set_run-int-state","text":"Defines the execution state of the JoinRoom class.","title":"void set_run (int state)"},{"location":"join/#void-draw_lpage-stdshared_ptr-sfrenderwindow-window","text":"A public method that draws the \"Start\" button and the game room on the specified window.","title":"void draw_lpage (std::shared_ptr&lt; sf::RenderWindow &gt; *window)"},{"location":"join/#voidcstart_lobby-window-window-registry-r-isystem-sys-int-run-client-client","text":"The public method that manages the game waiting room process. It sends a message to the server to indicate that the user wishes to join the room, then handles window events, renders the game system and the waiting room.","title":"voidcstart_lobby (Window &amp;window, registry &amp;r, ISystem sys, int *run, Client &amp;client)"},{"location":"list/","text":"ListRoom Class Reference class for listing room for client. include \"List_room.hpp\" Public Member Functions ListRoom () Construct a new List Room object. ListRoom() Class constructor. It initializes members and loads the font. ~ListRoom() Class destructor. void handle_event(sf::Event event, std::shared_ptr< sf::RenderWindow> window) This method handles events related to the user interface, such as closing the window and reacting to the hover and selection of the \"Join\" button. std::string get_room_name() This method returns the name of the selected room. int get_run() This method returns the current state of the class. void set_room_name(std::string name) This method sets the name of the room the user wishes to join. void set_run(int state) This method modifies the current state of the class. void draw_lpage(std::shared_ptr< sf::RenderWindow > *window) This method handles the rendering of the user interface, including the display of the \"Join\" button and the selected game room. void set_room_list(Room *room) This method sets the game room to be joined. void start_lobby( Window &window, registry &r, ISystem sys, int *run, std::string room, Client &client) This method is used to start the game room user interface. It handles events, rendering and creation of the game room.","title":"ListRoom Class Reference"},{"location":"list/#listroom-class-reference","text":"class for listing room for client. include \"List_room.hpp\"","title":"ListRoom Class Reference"},{"location":"list/#public-member-functions","text":"","title":"Public Member Functions"},{"location":"list/#listroom","text":"Construct a new List Room object.","title":"ListRoom ()"},{"location":"list/#listroom_1","text":"Class constructor. It initializes members and loads the font.","title":"ListRoom()"},{"location":"list/#listroom_2","text":"Class destructor.","title":"~ListRoom()"},{"location":"list/#void-handle_eventsfevent-event-stdshared_ptr-sfrenderwindow-window","text":"This method handles events related to the user interface, such as closing the window and reacting to the hover and selection of the \"Join\" button.","title":"void handle_event(sf::Event event, std::shared_ptr&lt; sf::RenderWindow&gt; window)"},{"location":"list/#stdstring-get_room_name","text":"This method returns the name of the selected room.","title":"std::string get_room_name()"},{"location":"list/#int-get_run","text":"This method returns the current state of the class.","title":"int get_run()"},{"location":"list/#void-set_room_namestdstring-name","text":"This method sets the name of the room the user wishes to join.","title":"void set_room_name(std::string name)"},{"location":"list/#void-set_runint-state","text":"This method modifies the current state of the class.","title":"void set_run(int state)"},{"location":"list/#void-draw_lpagestdshared_ptr-sfrenderwindow-window-this-method-handles-the-rendering-of-the-user-interface-including-the-display-of-the-join-button-and-the-selected-game-room","text":"","title":"void draw_lpage(std::shared_ptr&lt; sf::RenderWindow &gt; *window) &nbsp; This method handles the rendering of the user interface, including the display of the \"Join\" button and the selected game room."},{"location":"list/#void-set_room_listroom-room","text":"This method sets the game room to be joined.","title":"void set_room_list(Room *room)"},{"location":"list/#void-start_lobby-window-window-registry-r-isystem-sys-int-run-stdstring-room-client-client","text":"This method is used to start the game room user interface. It handles events, rendering and creation of the game room.","title":"void start_lobby( Window &amp;window, registry &amp;r, ISystem sys, int *run, std::string room, Client &amp;client)"},{"location":"lobby/","text":"","title":"Lobby"},{"location":"login/","text":"LoginPage Class Reference Class login page logic include \"loginpage.hpp\" Public Member Functions LoginPage () Construct a new Login Page object. LoginPage() Class constructor. Initializes members and loads font. ~LoginPage() Class destructor. void handle_event(sf::Event event, std::shared_ptr (wwindow), int sf, Window window) This method handles events related to the user interface, such as window closing, text zone navigation and input management. void handle_nav(sf::Event event, int sf) This method handles text zone navigation by highlighting the selected text zone. void handle_all_event(sf::Event event, std::shared_ptr wwindow, int sf, Window window) This method handles all user interface events, including input, window closing and navigation. void start_loginpage(Window &window, registry &r, ISystem sys, int run, sf::Event event, int sf, std::shared_ptr wwindow) This method is used to start the login page user interface. It handles events, user input and transition to the game. void draw_lpage(std::shared_ptr *(wwindow)) This method handles the rendering of the user interface, including the display of text boxes and the \"Enter game\" button. void set_playername(std::string plynm): This method sets the name of the player entered. void set_serverport(std::string srvprt) This method sets the entered server port. void set_ipadress(std::string ipdrss) This method sets the IP address of the server entered. void set_run(int run) This method modifies the current state of the class. int get_run() This method returns the current state of the class. std::string get_playername() This method returns the player name entered. std::string get_serverport() This method returns the server port entered. std::string get_ipadress() This method returns the server's IP address.","title":"LoginPage Class Reference"},{"location":"login/#loginpage-class-reference","text":"Class login page logic include \"loginpage.hpp\"","title":"LoginPage Class Reference"},{"location":"login/#public-member-functions","text":"","title":"Public Member Functions"},{"location":"login/#loginpage","text":"Construct a new Login Page object.","title":"LoginPage ()"},{"location":"login/#loginpage_1","text":"Class constructor. Initializes members and loads font.","title":"LoginPage()"},{"location":"login/#loginpage_2","text":"Class destructor.","title":"~LoginPage()"},{"location":"login/#void-handle_eventsfevent-event-stdshared_ptr-wwindow-int-sf-window-window","text":"This method handles events related to the user interface, such as window closing, text zone navigation and input management.","title":"void handle_event(sf::Event event, std::shared_ptr (wwindow), int sf, Window window)"},{"location":"login/#void-handle_navsfevent-event-int-sf","text":"This method handles text zone navigation by highlighting the selected text zone.","title":"void handle_nav(sf::Event event, int sf)"},{"location":"login/#void-handle_all_eventsfevent-event-stdshared_ptr-wwindow-int-sf-window-window","text":"This method handles all user interface events, including input, window closing and navigation.","title":"void handle_all_event(sf::Event event, std::shared_ptr wwindow, int sf, Window window)"},{"location":"login/#void-start_loginpagewindow-window-registry-r-isystem-sys-int-run-sfevent-event-int-sf-stdshared_ptr-wwindow","text":"This method is used to start the login page user interface. It handles events, user input and transition to the game.","title":"void start_loginpage(Window &amp;window, registry &amp;r, ISystem sys, int run, sf::Event event, int sf, std::shared_ptr wwindow)"},{"location":"login/#void-draw_lpagestdshared_ptr-wwindow","text":"This method handles the rendering of the user interface, including the display of text boxes and the \"Enter game\" button. void set_playername(std::string plynm): This method sets the name of the player entered.","title":"void draw_lpage(std::shared_ptr *(wwindow))"},{"location":"login/#void-set_serverportstdstring-srvprt","text":"This method sets the entered server port.","title":"void set_serverport(std::string srvprt)"},{"location":"login/#void-set_ipadressstdstring-ipdrss","text":"This method sets the IP address of the server entered.","title":"void set_ipadress(std::string ipdrss)"},{"location":"login/#void-set_runint-run","text":"This method modifies the current state of the class.","title":"void set_run(int run)"},{"location":"login/#int-get_run","text":"This method returns the current state of the class.","title":"int get_run()"},{"location":"login/#stdstring-get_playername","text":"This method returns the player name entered.","title":"std::string get_playername()"},{"location":"login/#stdstring-get_serverport","text":"This method returns the server port entered.","title":"std::string get_serverport()"},{"location":"login/#stdstring-get_ipadress","text":"This method returns the server's IP address.","title":"std::string get_ipadress()"},{"location":"message/","text":"","title":"Message"},{"location":"player/","text":"player Class Reference Player class. include \"player.hpp\" Public Member Functions Player(Sprite sprite, std::string name) The Player class constructor takes two parameters: sprite sprite The sprite associated with the player. std::string name : The player's name. ~Player() The destructor of the Player class. void move_player(Input input) This method moves the player according to the input supplied as a parameter. Input can be used to determine the player's direction of movement, for example in response to keyboard commands. Sprite get_sprite() This method returns the sprite associated with the player. The sprite represents the player's visual appearance in the game. std::string get_name() This method returns the player's name. The name can be used to identify the player in the game.","title":"player Class Reference"},{"location":"player/#player-class-reference","text":"Player class. include \"player.hpp\"","title":"player Class Reference"},{"location":"player/#public-member-functions","text":"","title":"Public Member Functions"},{"location":"player/#playersprite-sprite-stdstring-name","text":"The Player class constructor takes two parameters: sprite sprite The sprite associated with the player. std::string name : The player's name.","title":"Player(Sprite sprite, std::string name)"},{"location":"player/#player","text":"The destructor of the Player class.","title":"~Player()"},{"location":"player/#void-move_playerinput-input","text":"This method moves the player according to the input supplied as a parameter. Input can be used to determine the player's direction of movement, for example in response to keyboard commands.","title":"void move_player(Input input)"},{"location":"player/#sprite-get_sprite","text":"This method returns the sprite associated with the player. The sprite represents the player's visual appearance in the game.","title":"Sprite get_sprite()"},{"location":"player/#stdstring-get_name","text":"This method returns the player's name. The name can be used to identify the player in the game.","title":"std::string get_name()"},{"location":"registry/","text":"registry Class Reference class for handle registry. include \"registry.hpp\" Public Member Functions template sparse_array &register_component() This method registers a component type (Component) in the registry. It returns a reference to the array (sparse_array) associated with this component type. Each component type has a dedicated array to store specific data. template sparse_array &get_components() This method returns a reference to the array (sparse_array) associated with the specified component type. It is used to access data for a given component type. entity_t spawn_entity() This method creates a new entity and returns an entity_t object representing that entity. Entities are abstract objects used to link components together. entity_t entity_from_index(std::size_t idx) This method returns an entity according to the specified index. It can be used to obtain an existing entity from its index. void kill_entity(entity_t const &e) This method has no implementation in the code you've provided, but is probably intended to \"kill\" (or delete) a specified entity. template typename sparse_array ::reference_type add_component(entity_t const &to, Component &&c) This method adds a component (Component instance) to a specified entity. The use of && indicates that the component is added as an rvalue, which can be useful for memory management. template < typename Component> typename sparse_array< Component>::reference_type add_component(entity_t const &to, Component &c) This method adds a component (Component instance) to a specified entity, but this time as a lvalue (reference). template < typename Component, typename... Params> typename sparse_array< Component>::reference_type emplace_component(entity_t const &to, Params &&...p) This method could be used to add a component (Component instance) to an entity using the emplace construct. Params variadic parameters can be used to provide construction arguments. template void remove_component(entity_t const &from) This method could be used to remove a component from a specified entity. However, this method is not implemented in the code you've provided.","title":"registry Class Reference"},{"location":"registry/#registry-class-reference","text":"class for handle registry. include \"registry.hpp\"","title":"registry Class Reference"},{"location":"registry/#public-member-functions","text":"","title":"Public Member Functions"},{"location":"registry/#template-sparse_array-register_component","text":"This method registers a component type (Component) in the registry. It returns a reference to the array (sparse_array) associated with this component type. Each component type has a dedicated array to store specific data.","title":"template  sparse_array &amp;register_component()"},{"location":"registry/#template-sparse_array-get_components","text":"This method returns a reference to the array (sparse_array) associated with the specified component type. It is used to access data for a given component type.","title":"template  sparse_array &amp;get_components()"},{"location":"registry/#entity_t-spawn_entity","text":"This method creates a new entity and returns an entity_t object representing that entity. Entities are abstract objects used to link components together.","title":"entity_t spawn_entity()"},{"location":"registry/#entity_t-entity_from_indexstdsize_t-idx","text":"This method returns an entity according to the specified index. It can be used to obtain an existing entity from its index.","title":"entity_t entity_from_index(std::size_t idx)"},{"location":"registry/#void-kill_entityentity_t-const-e","text":"This method has no implementation in the code you've provided, but is probably intended to \"kill\" (or delete) a specified entity.","title":"void kill_entity(entity_t const &amp;e)"},{"location":"registry/#template-typename-sparse_arrayreference_type-add_componententity_t-const-to-component-c","text":"This method adds a component (Component instance) to a specified entity. The use of && indicates that the component is added as an rvalue, which can be useful for memory management.","title":"template  typename sparse_array::reference_type add_component(entity_t const &amp;to, Component &amp;&amp;c)"},{"location":"registry/#template-typename-component-typename-sparse_array-componentreference_type-add_componententity_t-const-to-component-c","text":"This method adds a component (Component instance) to a specified entity, but this time as a lvalue (reference).","title":"template &lt; typename Component&gt; typename sparse_array&lt; Component&gt;::reference_type add_component(entity_t const &amp;to, Component &amp;c)"},{"location":"registry/#template-typename-component-typename-params-typename-sparse_array-componentreference_type-emplace_componententity_t-const-to-params-p","text":"This method could be used to add a component (Component instance) to an entity using the emplace construct. Params variadic parameters can be used to provide construction arguments.","title":"template &lt; typename Component, typename... Params&gt; typename sparse_array&lt; Component&gt;::reference_type emplace_component(entity_t const &amp;to, Params &amp;&amp;...p)"},{"location":"registry/#template-void-remove_componententity_t-const-from","text":"This method could be used to remove a component from a specified entity. However, this method is not implemented in the code you've provided.","title":"template  void remove_component(entity_t const &amp;from)"},{"location":"room/","text":"Room Class Reference class for playerRoom. include \"room_client.hpp\" Public Member Functions void set_nb_players(int nb_players) This method sets the current number of players in the room. However, there seems to be a check to ensure that nb_players is less than 2 before updating the nb_players attribute. void draw(std::shared_ptr *window) This method is used to draw the room, in particular the button associated with the room, on a rendering window. Button get_button() This method returns the Button object associated with the room, presumably to allow other parts of the program to access and manipulate this button. void set_status() This method appears to set the status of the room according to the number of players. If the number of players reaches 2, the button color is set to red. void set_nb_player(int nb_players) This method sets the number of players in the room. std::string get_room_name() This method returns the room name.","title":"Room Class Reference"},{"location":"room/#room-class-reference","text":"class for playerRoom. include \"room_client.hpp\"","title":"Room Class Reference"},{"location":"room/#public-member-functions","text":"","title":"Public Member Functions"},{"location":"room/#void-set_nb_playersint-nb_players","text":"This method sets the current number of players in the room. However, there seems to be a check to ensure that nb_players is less than 2 before updating the nb_players attribute.","title":"void set_nb_players(int nb_players)"},{"location":"room/#void-drawstdshared_ptr-window","text":"This method is used to draw the room, in particular the button associated with the room, on a rendering window.","title":"void draw(std::shared_ptr *window)"},{"location":"room/#button-get_button","text":"This method returns the Button object associated with the room, presumably to allow other parts of the program to access and manipulate this button.","title":"Button get_button()"},{"location":"room/#void-set_status","text":"This method appears to set the status of the room according to the number of players. If the number of players reaches 2, the button color is set to red.","title":"void set_status()"},{"location":"room/#void-set_nb_playerint-nb_players","text":"This method sets the number of players in the room.","title":"void set_nb_player(int nb_players)"},{"location":"room/#stdstring-get_room_name","text":"This method returns the room name.","title":"std::string get_room_name()"},{"location":"server/","text":"Server Class Reference Public Member Functions Server(io_context &, int port) The server constructor that takes an io_context object and a port number as parameters. Server(Server &) A copy constructor. ~Server() The destructor of the class that releases the resources associated with the server. void send_to_client(std::string message, unsigned int client_id) This method is used to send a message to a specific client identified by its client_id. void send_to_all_client(std::string message) This method sends a message to all connected clients. void display_all_client() A method that could be used to display the list of connected clients. void start_receive(), void handle_receive(...), void handle_send(...), void run_service() These private methods are probably used to manage the sending and receiving of messages between the server and clients via the UDP protocol. unsigned int get_client_id(udp::endpoint endpoint) A method that appears to assign a unique identifier to a client based on its endpoint. void send(std::string message, udp::endpoint target_endpoint) A method for sending a message to a specific endpoint. unsigned int create_client_id(udp::endpoint endpoint) This method creates a client identifier based on the client endpoint. void client_disconnected(int id) This method manages the disconnection of a client based on its id.","title":"Server Class Reference"},{"location":"server/#server-class-reference","text":"","title":"Server Class Reference"},{"location":"server/#public-member-functions","text":"","title":"Public Member Functions"},{"location":"server/#serverio_context-int-port","text":"The server constructor that takes an io_context object and a port number as parameters.","title":"Server(io_context &amp;, int port)"},{"location":"server/#serverserver","text":"A copy constructor.","title":"Server(Server &amp;)"},{"location":"server/#server","text":"The destructor of the class that releases the resources associated with the server.","title":"~Server()"},{"location":"server/#void-send_to_clientstdstring-message-unsigned-int-client_id","text":"This method is used to send a message to a specific client identified by its client_id.","title":"void send_to_client(std::string message, unsigned int client_id)"},{"location":"server/#void-send_to_all_clientstdstring-message","text":"This method sends a message to all connected clients.","title":"void send_to_all_client(std::string message)"},{"location":"server/#void-display_all_client","text":"A method that could be used to display the list of connected clients.","title":"void display_all_client()"},{"location":"server/#void-start_receive-void-handle_receive-void-handle_send-void-run_service","text":"These private methods are probably used to manage the sending and receiving of messages between the server and clients via the UDP protocol.","title":"void start_receive(), void handle_receive(...), void handle_send(...), void run_service()"},{"location":"server/#unsigned-int-get_client_idudpendpoint-endpoint","text":"A method that appears to assign a unique identifier to a client based on its endpoint.","title":"unsigned int get_client_id(udp::endpoint endpoint)"},{"location":"server/#void-sendstdstring-message-udpendpoint-target_endpoint-a-method-for-sending-a-message-to-a-specific-endpoint","text":"","title":"void send(std::string message, udp::endpoint target_endpoint)&nbsp; A method for sending a message to a specific endpoint."},{"location":"server/#unsigned-int-create_client_idudpendpoint-endpoint","text":"This method creates a client identifier based on the client endpoint.","title":"unsigned int create_client_id(udp::endpoint endpoint)"},{"location":"server/#void-client_disconnectedint-id","text":"This method manages the disconnection of a client based on its id.","title":"void client_disconnected(int id)"}]}